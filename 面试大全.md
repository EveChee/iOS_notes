# 面试大全
##Objective-C 基础
* 类（class）：编译器仅为每个类创建了一个可以访问的对象，一个类对象指定如何创建该类的新对象

* 类别（category）：可以在不获悉，不改变原来代码的情况下往里面添加新的方法，只能添加，不能删除修改，并且如果类别和原来类中的方法产生名称冲突，根据编译文件顺序来覆盖。作用：
    * 将类的实现分散到多个不同文件或多个不同框架中。
    * 声明私有方法，某一个方法只实现，不声明，相当于私有方法。
    * 向对象添加非正式协议。
    
* 类拓展（class extension）：私有的category，可以添加属性,添加的方法是必须要实现的，不然会出现警告。

* 协议（protocol）：<br>
    * 正式协议：@protocal修饰，协议中两个修饰词：“必须实现(@requied)”和“可选实现(@optional)”
    * 非正式协议：就是类别（category），即凡是NSObject或其子类的类别，都是非正式协议。非正式协议使用interface修饰
    * 类别与类扩展的区别：
        1. 类别中只能增加方法；
        2. 是的，你没看错，类扩展不仅可以增加方法，还可以增加实例变量（或者合成属性），只是该实例变量默认是@private类型的（作用范围只能在自身类，而不是子类或其他地方）；
        3. 类扩展中声明的方法没被实现，编译器会报警，但是类别中的方法没被实现编译器是不会有任何警告的。这是因为类扩展是在编译阶段被添加到类中，而类别是在运行时添加到类中。
        4. 类扩展不能像类别那样拥有独立的实现部分（@implementation部分），也就是说，类扩展所声明的方法必须依托对应类的实现部分来实现。
        5. 定义在 .m 文件中的类扩展方法为私有的，定义在 .h 文件（头文件）中的类扩展方法为公有的。类扩展是在 .m 文件中声明私有方法的非常好的方式。
* @protocol 和 category 中如何使用 @property
    1. 在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性
    2. category 使用 @property 也是只会生成setter和getter方法的声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数：
        1. objc_setAssociatedObject
        2. objc_getAssociatedObject
* 对象（object）：带isa指针的结构体

* 实例变量（instance variable）：object-specificstorage

* 成员变量（member variable）：
    * @public:在任何地方都能直接访问对象的成员变量
    * @private:只能在当前类的对象方法中直接访问,如果子类要访问需要调用父类的get/set方法
    * @protected:可以在当前类及其子类对象方法中直接访问(系统默认下是用它来修饰的)
    * @package:在同一个包下就可以直接访问，比如说在同一个框架
    * 默认：
        * 在.m中成员变量的修饰符为@private.
        * 在.h中成员变量的修饰符@protected.
    
    访问成员变量可以通过self->变量名字，也可以直接通过变量名字去访问，
    无论父类是在@interface还是@implementation声明的成员变量子类都能拥有；但是子类能不能直接通过变量名来访问父类中定义的成员变量是需要看父类中定义的成员变量是由什么修饰符来修饰的。
    
* 属性（property）：
    * @property = ivar + access method; 
    * access method = getter + setter; 
    * 完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。需要强调的是，这个过程由编译 器在编译期执行，所以编辑器里看不到这些“合成方法”(synthesized method, `@synthesize 属性名 = _属性名; `)的源代码。除了生成方法代码 getter、setter 之外，编译器还要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。大致生成了五个东西：
        1. OBJC_IVAR_$类名$属性名称 ：该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远。
        2. setter与getter方法对应的实现函数
        3. ivar_list ：成员变量列表
        4. method_list ：方法列表
        5. prop_list ：属性列表
    * 也就是说我们每次在增加一个属性,系统都会在ivar_list中添加一个成员变量的描述,在method_list中增加setter与getter方法的描述,在属性列表中增加一个属性的描述,然后计算该属性在对象中的偏移量,然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转.
    * @property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize和 @dynamic都没写，那么默认的就是`@syntheszie var = _var;`
        1. 使用@property+@synthesize方式，能够让编译器在编译期间自动生成setter/getter这两个方法的实现，配合属性声明使用。但是，当你自己又写了一遍setter或getter 或者两个都重写了之后，你自己写的方法会被调用，而编译器生成的方法会被屏蔽。
        2. 使用@property+@dynamic方式，@dynamic 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。
    
    >修饰符：
    
    * atomic：setter/getter函数，是一个原子操作，多线程安全。
    
        如果有多个线程同时调用setter的话，不会出现某一个线程执行完setter全部语句之前，另一个线程开始执行setter情况，相当于函数头尾加了锁一样，可以保证数据的完整性。通俗的说：一个A线程，调用了getter方法，并且执行一半，此时线程B调用了setter方法，但是A线程得到的还是一个完整的对象或者数据； 
        
        atomic 的getter和setter：处理之前要做的事：都要检查有没有其它线程例如B正在用这个方法，有的话要等正在使用synchronized方法的线程B运行完这个方法后再运行此线程A,没有的话,直接运行。
    * nonatomic：不保证setter/getter的原子性
    
    
    * retain：表示持有特性，setter方法对参数进行release旧值再retain新值，传入参数的retaincount会+1;
    * copy：setter方法进行Copy操作，与retain处理流程一样，先旧值release，再 Copy出新的对象，retainCount为1。这是为了减少对上下文的依赖而引入的机制。
        1. 例子：这个写法会出什么问题： @property (copy) NSMutableArray *array;
            1. 添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为copy就是复制一个不可变NSArray的对象；
            2. 使用了atomic属性会严重影响性能。
        2. 实现copy，具体步骤：
            1. 需声明该类遵从NSCopying协议
            2. 实现NSCopying协议。该协议只有一个方法:
                `- (id)copyWithZone: (NSZone*) zone`
            3. 注意：一提到让自己的类用 copy 修饰符，我们总是想覆写copy方法，其实真正需要实现的却是“copyWithZone”方法。
            4. 如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议。
    * assign：是setter方法直接赋值，不进行任何retain操作
    * getter=getterName，setter=setterName，设置setter与 getter的方法名
    * weak：表明该属性定义了一种“非拥有关系” (nonowning relationship)。为这种属性设置新值时，设置方法既不保留新值，也不释放旧值。此特质同assign类似， 然而在属性所指的对象遭到摧毁时，属性值也会清空(nil out)，weak必须用于OC对象。以下情况用weak
        1. 在ARC中,在有可能出现循环引用的时候,往往通过要让其中一端使用weak来解决,比如:delegate代理属性
        2. 自身已经对它进行一次强应用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong。
    * strong：引用对象，引用计数+1
    * readwrite：可读可写特性，生成setter跟getter方法
    * readonly：只读特性，只生成getter方法，不生成setter方法，不希望属性在类外改变
    * ARC下，不显式指定任何属性关键字时
        * 对应基本数据类型默认关键字是：`atomic,readwrite,assign`
        * 对于普通的OC对象：`atomic,readwrite,strong`

* @import、#import、@class、#include：
    * #import：相应的头文件只导入一次，不会重复导入，相当于#include和#pragma once；
    * #import""引入的是本地工程的文件，""会先查找用户目录下文件是否存在，或者说是User Header Search Paths，如果不存在，会继续查找库目录，也就是System Header Search Paths
    * #import<>引入的是系统库的文件，<>只会查找库目录（System Header Search Paths），如果查找失败，并不会继续查找用户目录。
    #include：是C/C++导入头文件的关键字
    * @class：是告诉编译器某个类的声明，并不导入类的头文件，可以解决头文件的相互包含
    * @import：告诉编译器需要使用某库，之后编译器会优化编译头文件和缓存编译结果的过程，编译器会根据实际情况导入相应头文件。

* 继承、多继承：Objective-C是不支持多继承的，可以通过protocol进行多继承
    
* id：对象标识符，用于所有对象的泛型类型，忽略具体的类，并且用于一个类的实例以及类对象自身，在面向对象架构的Objective-C中id代替int（c架构）作为方法默认返回值；本身不提供任何关于对象的信息，除了它本身是一个对象的这个信息。从某种意义上来说，一个程序通常需要得到更多有关一个对象它所包含的特定信息。因为id类型标识符无法为编译器提供这种特定信息，这些对象必须在运行时能够提供出这些信息。

* selector：选择器，消息的名称；选择器的名字包含名字的所有部分，包括冒号

* nil：用于定义一个空对象，一个值为0的id。id、nil以及其它基础类型可以在objc/objc.h中找到Objective-C定义。
    发送消息给nil，Objective-C中，发送消息给nil是有效的—只是在运行时不会产生什么效果。在Cocoa 中可以有几个方面来利用这种特性。从发送到nil的消息返回的值同样也是有效的:
    * 如果方法返回一个对象，那么一条发往nil 的消息将返回0 (nil). 例如：
    
        ```
        Person *motherInLaw = [[aPerson spouse] mother];
        ```
        如果这里的 spouse 对象是 nil, 那么 mother 会发送到nil 并且方法会返回 nil.
    * 如果方法返回任何指针类型, 任何整型的表小于或者等于sizeof(void*), 一个float,  double,long double, 或者long long, 那么一条消息发送到nil 将返回 0.
    * 如果方法返回一个 struct, 就像 Mac OS X ABI Function Call Guide 定义的那样，从寄存器中返回，那么一条消息发往nil 将对于每个struct中的成员返回 0.0 ， 其它 struct 数据类型不会被填充没0
    * 如果方法返回任何非上述的值类型，那么发往 nil 消息的返回值将是undefined.

* load 和 initialize
    * `+(void)load`
        1. 当类加载到OC运行时环境(内存)中的时候,就会调用一次(一个类只会加载一次).
        2. 程序一启动就会调用.
        3. 程序运行过程中,只会调用1次
        4. 在程序启动的时候会加载所有的类和分类，并调用所有类和分类的+load方法
        5. 先加载父类，再加载子类；也就是先调用父类的+load，再调用子类的+load
        6.  先加载元原始类，再加载分类
        7. 不管程序运行过程有没有用到这个类，都会调用+load加载
    * ` +(void)initialize`
        1. 当第一次使用这个类的时候(比如调用了类的某个方法)才会调用.
        2. 并非程序一启动就会调用.
        3. 在第一次使用某个类时（比如创建对象等），就会调用一次+initialize方法
        4. 一个类只会调用一次+initialize方法，先调用父类的，再调用子类的
    * 两者都不需要显示使用super调用父类中的方法
        * 当我们定义-(id)init和-(void)dealloc方法时，我们总是需要使用super关键字来调用父类的方法，让父类也完成相同的操作。这是因为对对象的初始化和销毁过程，Objective-C不像C++,C#那样会自动调用父类默认构造函数。
        * 但是+(void)initialize和+(void)load不同，我们并不需要在这两个方法的实现中使用super调用父类的方法
        * super的方法会成功调用，但是这是多余的，因为runtime对自动对父类的+(void)load方法进行调用，而+(void)initialize则会随子类自动激发父类的方法（如Apple文档中所言）不需要显示调用。另一方面，如果父类中的方法用到的self（像示例中的方法），其指代的依然是类自身，而不是父类。
    * 总结
    
	       |+(void)load	 | +(void)initialize
--------- | --------- | -------------
|执行时机	|在程序运行后立即执行|	在类的方法第一次被调时执行
|若自身未定义，是否沿用父类的方法？	|否	|是
|类别中的定义	|全都执行，但后于类中的方法	|覆盖类中的方法，只执行一个

* OC是一门动态运行时语言
    * 主要是将数据类型的确定由编译时，推迟到了运行时。 这个问题其实浅涉及到两个概念，运行时和多态。
    * 运行时机制: 运行时机制使我们直到运行时才去决定一个对象的类别，以及调用该类别对象指定方法。
    * 多态：同对象以自己的方式响应相同的消息的能力叫做多态。意思就是假设生物类（life）都用有一个相同的方法-eat; 那人类属于生物，猪也属于生物，都继承了life后，实现各自的eat，但是调用是我们只需调用各自的eat方法。 也就是不同的对象以自己的方式响应了相同的消息（响应了eat这个选择器）。


* runloop


* 性能测试：
     Profile-> Instruments ->Time Profiler

* OC中的可变类型跟不可变类型
    * 可修改不可修改的集合类。这个我个人简单理解就是可动态添加修改和不可动态添加修改一样。
    * 比如NSArray和NSMutableArray。前者在初始化后的内存空间就是固定不可变的，后者可以添加等，可以动态申请新的内存空间。

* 线程:线程执行应用程序中的代码

* 进程:系统中正在运行的程序, 进程为应用程序开辟独立的空间,一条进程至少会包含一条线程

* 多线程
    1. 创建多线程：   
        1. 使用NSThread创建、
        2. 使用GCD的dispatch、
        3. 使用子类化的NSOperation,然后将其加入NSOperationQueue;在主线程执行代码，方法是performSelectorOnMainThread，如果想延时执行代码可以用performSelector:onThread:withObject:waitUntilDone:
    2. 作用：可以将耗时操作放在子线程中执行,这样就不会阻塞主线程的UI操作

* 设计模式
    设计模式并不是一种新技术，而是一种编码经验，使用比如Java中的接口，iPhone中的协议，继承关系等基本手段，用比较成熟的逻辑去处理某一种类型的事情，总结为所谓设计模式。面向对象编程中，Java已经归纳了23种设计模式。
    1. 代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用.比如一个工厂生产了产品，并不想直接卖给用户，而是搞了很多代理商，用户可以直接找代理商买东西，代理商从工厂进货.常见的如QQ的自动回复就属于代理拦截，代理模式在iphone中得到广泛应用.
    2. 单例模式：说白了就是一个类不通过alloc方式创建对象，而是用一个静态方法返回这个类的对象。系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为，比如想获得[UIApplication sharedApplication];任何地方调用都可以得到 UIApplication的对象，这个对象是全局唯一的。
    3. 观察者模式： 当一个物体发生变化时，会通知所有观察这个物体的观察者让其做出反应。实现起来无非就是把所有观察者的对象给这个物体，当这个物体的发生改变，就会调用遍历所有观察者的对象调用观察者的方法从而达到通知观察者的目的。

* 浅复制和深复制
    * 浅层复制：只复制指向对象的指针，而不复制引用对象本身。
    * 深层复制：复制引用对象本身。
    * 例子：有个A对象，复制一份后得到A_copy对象后，对于浅复制来说，A和A_copy指向的是同一个内存资源，复制的只不过是是一个指针，对象本身资源还是只有一份，那如果我们对A_copy执行了修改操作,那么发现A引用的对象同样被修改，这其实违背了我们复制拷贝的一个思想。深复制就好理解了,内存中存在了两份独立对象本身。
    * 通俗的说：
        * 浅复制好比你和你的影子，你完蛋，你的影子也完蛋
        * 深复制好比你和你的克隆人，你完蛋，你的克隆人还活着。

* KVO和KVC
    * KVC(**Key-Value-Coding**):一种间接更改对象状态的方式，其实现方法是使用字符串来描述对象需要更改的属性
        1. 使用valueForKey:时，KVC会自动将标量值(int、float、struct等)翻入NSNumber或NSValue中包装成一个对象，然后返回。因此，KVC有自动包装功能。
        2. KVC可以对对象进行批量更改
        3. 除了通过键设置值外，KVC还支持键路径，像文件系统路径一样，其实就是属性链式访问
        4. 优点：
            1. 无论变量是私有还是只读,都能更改
            2. 对象如果是Id类型,也能对其赋值
        5. 内部实现：一个对象在调用setValue的时候，
            1. 首先根据方法名找到运行方法的时候所需要的环境参数。
            2. 他会从自己isa指针结合环境参数，找到具体的方法实现的接口。
            3. 再直接查找得来的具体的方法实现。
    * KVO(**Key-Value-Observing**):键值观察机制，它提供一种机制，当指定的对象的属性被修改后，则对象就会接受到通知。简单的说就是每次指定的被观察的对象的属性被修改后，KVO就会自动通知相应的观察者了。当观察者为一个对象的属性进行了注册，被观察对象的isa指针被修改的时候，isa指针就会指向一个中间类，而不是真实的类。所以isa指针其实不需要指向实例对象真实的类。所以我们的程序最好不要依赖于isa指针。在调用类的方法的时候，最好要明确对象实例的类名。
        * 对于系统是根据keypath去取的到相应的值发生改变，理论上来说是和kvc机制的道理是一样的。
        * 添加监听器：
        `-(void)addObserver:(NSObject *)anObserver forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(void *)context`
        * 属性改变时调用：`-(void) observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)contextkeyPath `
        * 移除监听器：`-(void)removeObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath`
    * 对于kvc机制如何通过key寻找到value：
        1. “当通过KVC调用对象时，比如：[self valueForKey:@”someKey”]时，程序会自动试图通过几种不同的方式解析这个调用。首先查找对象是否带有 someKey 这个方法，如果没找到，会继续查找对象是否带有someKey这个实例变量(iVar)，如果还没有找到，程序会继续试图调用 -(id) valueForUndefinedKey:这个方法。如果这个方法还是没有被实现的话，程序会抛出一个NSUndefinedKeyException异常错误。
        2. (cocoachina.com注：Key-Value Coding查找方法的时候，不仅仅会查找someKey这个方法，还会查找getsomeKey这个方法，前面加一个get，或者_someKey以及_getsomeKey这几种形式。同时，查找实例变量的时候也会不仅仅查找someKey这个变量，也会查找_someKey这个变量是否存在。)
        3. 设计valueForUndefinedKey:方法的主要目的是当你使用-(id)valueForKey方法从对象中请求值时，对象能够在错误发生前，有最后的机会响应这个请求。这样做有很多好处，下面的两个例子说明了这样做的好处。“



* 客户端的缓存机制
    1. 缓存可以分为：内存数据缓存、数据库缓存、文件缓存
    2. 每次想获取数据的时候
        1. 先检测内存中有无缓存
        2. 再检测本地有无缓存(数据库\文件)
        3. 最终发送网络请求
        4. 将服务器返回的网络数据进行缓存（内存、数据库、文件）， 以便下次读取

* frame和bounds有什么不同
    * frame指的是：该view在父view坐标系统中的位置和大小。(参照点是父亲的坐标系统)
    * bounds指的是：该view在本身坐标系统中 的位置和大小。(参照点是本身坐标系统)

* 谓词:NSPredicate

* delegate：代理的目的是改变或传递控制链。允许一个类在某些特定时刻通知到其他类，而不需要获取到那些类的指针。可以减少框架复杂度。另外一点，代理可以理解为java中的回调监听机制的一种类似。
    
    

* block
    * Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。
    * block是一段预先准备好的代码,它可以当作参数传递,是一种数据类型,是一个匿名的函数。
    * block本质就是一个对象
         * 在Objective-C语言中，一共有3种类型的block：
            1. _NSConcreteGlobalBlock 全局的静态block，不会访问任何外部变量。
            2. _NSConcreteStackBlock 保存在栈中的block，当函数或方法返回时会被销毁。
            3. _NSConcreteMallocBlock 保存在堆中的block，当引用计数为0时会被销毁。
        * 如何定义这3种类型的block?
             1. 定义全局的静态block: 不访问任何的外部变量的block或者访问的外部变量是静态变量的block。(不区分是否是arc环境或非arc环境)
             
             ```
            例如：不访问外部变量
            globalBlock = ^{
                NSLog(@"globalBlock");
            };
            访问静态的外部变量block,相当于全局函数。
            static int val2 = 10; // 静态变量
            globalBlock = ^{
                NSLog(@"globalBlock = %d",val2++);
            };
             ```
             2. 定义保存在栈中的block。
                1. 在非ARC下,访问了外部变量且变量不是静态变量的block,默认就是栈block。当函数或方法返回时会被销毁。

                    ```
                    int val = 10;
                    stackBlock = ^{
                        NSLog(@"value = %d",val);
                    };
                    ```
                
                2. 在ARC下
                
                    ```
                    __weak Blk stackBlock = ^{
                NSLog(@"value = %d",val);
                };
                ```
            3. 定义保存在堆中的block
                    1. 在非ARC环境下,只要调用栈block的copy方法系统就会将栈block拷贝到堆中,变成堆block。
                    
                        ```
                    // 在非ARC下,在不使用heapBlock的时候要调用release方法。
                    heapBlock = [stackBlock copy];
                    ```
                    2.  在ARC环境下,只要用strong修饰且没有访问外部静态变量或者由函数返回的block都会移动到堆上。
                        
                        ```
                         heapBlock = ^{
                NSLog(@"value = %d",val);
            };
                        ```
        
        * Block的定义格式
            
            ```
             返回值类型 (^block变量名)(形参列表) = ^(形参列表) {
                            语句;
                            ...
            };
            
            使用typedef定义Block类型
            typedef返回值类型(^block类型名称)(形参列表);
            注：不带参数和无返回值的block,不带参数的时候(形参列表)可省略
            ```
        
        * 作用：
            1. Block封装了一段代码,可以在任何时候执行
            2. Block可以作为函数参数或者函数的返回值,而其本身有可以带输入参数或返回值
            3. 尽量多用block,在多线程,异步任务,集合变量,集合排序,动画专场用的很多。
        * 注意:
            1. block默认不能修改外面的局部变量
            2. block内部可以修改是用___block修饰的局部变量
            3. block内部可以访问外部定义的局部变量
                    
* const
    
    ```
    const int a;
    int const a;
    const int *a;
    int * const a;
    int const * a const;
    ```
    1. 前两个的作用是一样，a是一个常整型数。
    2. 第三个意味着a是一个指向常整型数的指针（也就是，整型数是不可修改的，但指针可以）。
    3. 第四个意思a是一个指向整型数的常指针（也就是说，指针指向的整型数是可以修改的，但指针是不可修改的）。
    4. 最后一个意味着a是一个指向常整型数的常指针（也就是说，指针指向的整型数是不可修改的，同时指针也是不可修改的）。
    
* static
    1. 函数体内 static 变量的作用范围为该函数体，不同于 auto 变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；
    2.  static修饰的全局变量是一个内部变量，只能在本文件中使用，其他文件不能使用；
    3. static修饰的函数是一个内部函数，只能在本文件中调用，其他文件不能调用
    4. 在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；
    5. 在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的static 成员变量。
    6. static修饰的局部变量只会初始化一次，并且在程序退出时才会回收内存

* Objective-C堆和栈的区别
    * 管理方式：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆来说，释放工作由程序员控制，容易产生memory leak。
    * 申请大小：
        * 栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因 此，能从栈获得的空间较小。
        * 堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。
    * 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出
    * 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。
    * 分配效率：栈是机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的。

* C和objc 如何混用
    1. obj-c的编译器处理后缀为m的文件时，可以识别obj-c和c的代码，处理mm文件可以识别obj-c,c,c++代码，但cpp文件必须只能用c/c++代码，而且cpp文件include的头文件中，也不能出现obj-c的代码，因为cpp只是cpp
    2. 在mm文件中混用cpp直接使用即可，所以obj-c混cpp不是问题
    3. 在cpp中混用obj-c其实就是使用obj-c编写的模块是我们想要的。
    
    * 如果模块以类实现，那么要按照cpp class的标准写类的定义，头文件中不能出现obj-c的东西，包括#import cocoa的。实现文件中，即类的实现代码中可以使用obj-c的东西，可以import,只是后缀是mm。
    * 如果模块以函数实现，那么头文件要按c的格式声明函数，实现文件中，c++函数内部可以用obj-c，但后缀还是mm或m。
    * 总结：只要cpp文件和cpp include的文件中不包含obj-c的东西就可以用了，cpp混用obj-c的关键是使用接口，而不能直接使用 实现代 码，实际上cpp混用的是obj-c编译后的o文件，这个东西其实是无差别的，所以可以用。obj-c的编译器支持cpp

* 后台执行内容有几种形式？
    *  一般的应用在进入后台的时候可以获取一定时间来运行相关任务，也就是说可以在后台运行一小段时间(10S左右)。
        1. 后台播放音乐
        2. 后台GPS跟踪
        3. 后台voip支持
    * 现在
     ![AB65E687-D331-41A7-AA29-01E481E96EFF](media/15222324897236/AB65E687-D331-41A7-AA29-01E481E96EFF.png)
    ![49BACC8D-0E6E-4144-BE61-A7D93E408D11](media/15222324897236/49BACC8D-0E6E-4144-BE61-A7D93E408D11.png)



##内存管理
*  自动释放池
    
    自动释放池以栈的形式实现:当你创建一个新的自动释放池时，它将被添加到栈顶。当一个对象收到发送autorelease消息时,它被添加到当前线程的处于栈顶的自动释放池中,当自动释放池被回收时,它们从栈中被删除, 并且会给池子里面所有的对象都会做一次release操作.

* 内存分区
    1. 代码区：存放函数二进制代码
    2. 数据区：系统运行时申请内存并初始化，系统退出时由系统释放。存放全局变量、静态变量、常量
    3. 堆区：通过malloc等函数或new等操作符动态申请得到，需程序员手动申请和释放
    4. 栈区：函数模块内申请，函数结束时由系统自动释放。存放局部变量、函数参数
    
* Objective-C支持三种方式的内存管理：
    * 自动垃圾回收及引用统计，Automatic Reference Counting (ARC), 自动引用统计，编译器会推断出所有对象的生命周期
    * Manual Reference Counting (MRC), 手动引用统计，有时也叫MRR，即手动保持，释放。用于你完全掌控并决定对象的生命周期。详情可以参考 [Advanced Memory Management Programming Guide](http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html#//apple_ref/doc/uid/10000011i).
    * Garbage collection, 垃圾回收，将决定对象生命周期的责任传递给自动回收器。可以参考[Garbage Collection Programming Guide](http://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/GarbageCollection/Introduction.html#//apple_ref/doc/uid/TP40002431).

* 内存泄漏
    * 用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束。
    * 追踪内存泄漏问题:
        1. 设置NSZombieEnabled
        2. 静态分析内存泄露(shift+command+b)
        3. 使用动态分析Instruments的leaks工具

* 内存溢出

    当程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个int,但给它存了long才能存下的数。

## UIKit
* 控制器生命周期
    * viewDidLoad和viewDidUnload何时调用：viewDidLoad在view从nib文件初始化时调用，loadView在controller的view为nil时调用。此方法在编程实现view时调用，view控制器默认会注册memory warning notification，当view controller的任何view没有用的时候，viewDidUnload会被调用，在这里实现将retain的view release，如果是retain的IBOutlet view 属性则不要在这里release，IBOutlet会负责release 。
    * 过程：
        1. 首先判断控制器是否有视图，如果没有就调用loadView方法创建：通过storyboard或者代码；
        2. 随后调用viewDidLoad，可以进行下一步的初始化操作；只会被调用一次；
        3. 在视图显示之前调用viewWillAppear；该函数可以多次调用；
        4. 视图viewDidAppear
        5. 在视图显示之前调用viewWillDisappear；该函数可以多次调用；（如需要）；
        6. 在布局变化前后，调用viewWill/DidLayoutSubviews处理相关信息；
    
* 为什么要在主线程更新UI
    * 因为UIKit框架都不是线程安全的!为了得到更好的用户体验,UIKit框架牺牲了线程安全,所以我们要在主线程更新UI

* UIView和 CALayer 之间的关系
    * CALayer是用来绘制内容的，不能处理用户事件。直接继承自NSObject。
    * UIView是用来显示内容的，可以处理用户事件。直接继承自UIResponser。
    * UIView是CALayer的代理

##runtime
* runtime是一套比较底层的纯C语言API, 属于1个C语言库, 包含了很多底层的C语言API。在我们平时编写的OC代码中, 程序运行过程时, 其实最终都是转成了runtime的C语言代码, runtime算是OC的幕后工作者。例子如下：
    
        ```
        OC : 
        [[Person alloc] init] 
        runtime : 
        objc_msgSend(objc_msgSend(“Person” , “alloc”), “init”)
        ```  
    * runtime是属于OC的底层, 可以进行一些非常底层的操作(用OC是无法现实的, 不好实现)
        1. 在程序运行过程中, 动态创建一个类(比如KVO的底层实现)
        2. 在程序运行过程中, 动态地为某个类添加属性\方法, 修改属性值\方法。
        3. 遍历一个类的所有成员变量(属性)\所有方法.例如：我们需要对一个类的属性进行归档解档的时候属性特别的多，这时候，我们就会写很多对应的代码，但是如果使用了runtime就可以动态设置！归档和解档的案例如下：
            
            ```
        - (void)encodeWithCoder:(NSCoder *)aCoder {
    unsigned int count = 0;
    Ivar *ivars = class_copyIvarList([self class], &count);
    for (int i = 0; i < count; i++) {
        // 取出i位置对应的成员变量
        Ivar ivar = ivars[i];
        // 查看成员变量
        const char *name = ivar_getName(ivar);
        // 归档
        NSString *key = [NSString stringWithUTF8String:name];
        id value = [self valueForKey:key];
        [aCoder encodeObject:value forKey:key];
    }
    free(ivars);
}
        ```

            ```
            - (nullable instancetype)initWithCoder:(NSCoder *)aDecoder {
    if (self = [super init]) {
        unsigned int count = 0;
        Ivar *ivars = class_copyIvarList([self class], &count);
        for (int i = 0; i < count; i++) {
            // 取出i位置对应的成员变量
            Ivar ivar = ivars[i];
            // 查看成员变量
            const char *name = ivar_getName(ivar);
            // 归档
            NSString *key = [NSString stringWithUTF8String:name];
            id value = [aDecoder decodeObjectForKey:key];
            // 设置到成员变量身上
            [self setValue:value forKey:key];
        }
        free(ivars);
    }
    return self;
}
    ```
    
        4. 相关应用
            * NSCoding(归档和解档, 利用runtime遍历模型对象的所有属性)
            * 字典 –> 模型 (利用runtime遍历模型对象的所有属性, 根据属性名从字典中取出对应的值, 设置到模型的属性上)
            * KVO(利用runtime动态产生一个类)
            * 用于封装框架(想怎么改就怎么改) 
        5. 相关函数：可到<objc/runtime.h>中查看头文件
            * objc_msgSend : 给对象发送消息
            * class_copyMethodList : 遍历某个类所有的方法
            * class_copyIvarList : 遍历某个类所有的成员变量
            * class_….. 
        6. Ivar : 成员变量；Method : 成员方法 

* 消息转发
    * OS开发过程中我们经常会碰到这样的报错：`unrecognized selector sent to instance`，原因是我们调用了一个不存在的方法。用OC消息机制来说就是：消息的接收者找不到对应的selector，这样就启动了消息转发机制，我们可以通过代码在消息转发的过程中告诉对象应该如何处理未知的消息
    * 下在抛出异常之前也就是消息转发过程中的步骤：
        1. 第一步：对象在收到无法解读的消息后，首先会调用`+(BOOL)resolveInstanceMethod:(SEL)sel`或者`+ (BOOL)resolveClassMethod:(SEL)sel`, 询问是否有动态添加方法来进行处理，处理实例如下

            ```
        //People.m
        void speak(id self, SEL _cmd){
            NSLog(@"Now I can speak.");
        }
        + (BOOL)resolveInstanceMethod:(SEL)sel {
            
            NSLog(@"resolveInstanceMethod:  %@", NSStringFromSelector(sel));
            if (sel == @selector(speak)) {
                class_addMethod([self class], sel, (IMP)speak, "V@:");
                return YES;
            }
            return [super resolveInstanceMethod:sel];
        }
        ```
        
            当People 收到了未知 speak选择子的消息的时候，如果是实例方法会首选调用上文的`resolveInstanceMethod:`方法，方法内通过判断选择子然后通过`class_addMethod`方法动态添加了一个speak的实现方法来解决掉这条未知的消息，此时消息转发过程提前结束。
但是当People 收到fly 这条未知消息的时候，第一步返回的是No，也就是没有动态新增实现方法的时候就会调用第二步

        2. 第二步：既然第一步已经问过了，没有新增方法，那就问问有没有别人能够帮忙处理一下啊，调用的是`- (id)forwardingTargetForSelector:(SEL)aSelector`这个方法,上文我们说到People接收到了一条选择子为fly的未知消息，我们可以看到控制台已经打印了`resolveInstanceMethod: fly`，代表第一步已经问过了，那么第二步问一下是否有别的类能帮忙处理吗？代码如下：

            ```
            - (id)forwardingTargetForSelector:(SEL)aSelector {
                NSLog(@"forwardingTargetForSelector:  %@", NSStringFromSelector(aSelector));
                Bird *bird = [[Bird alloc] init];
                if ([bird respondsToSelector: aSelector]) {
                    return bird;
                }
                return [super forwardingTargetForSelector: aSelector];
            }
            // Bird.m
            - (void)fly {
                NSLog(@"I am a bird, I can fly.");
            }
            ```

            通过`- (id)forwardingTargetForSelector:(SEL)aSelector`的处理，bird能够处理这条消息，所以这条消息被bird成功处理，消息转发流程提前结束。控制台打印

            ```
            forwardingTargetForSelector:  fly
            I am a bird, I can fly.
            ```
            但是如果`- (id)forwardingTargetForSelector:(SEL)aSelector`也找不到能够帮忙处理这条未知消息，那就会走到最后一步，这步也是代价最大的一步

        3. 第三步：调用`- (void)forwardInvocation:(NSInvocation *)anInvocation`，在调用`forwardInvocation:`之前会调用`- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector`方法来获取这个选择子的方法签名，然后在`-(void)forwardInvocation:(NSInvocation *)anInvocation`方法中你就可以通过anInvocation拿到相应信息做处理，实例代码如下

            当People 收到一条 选择子为code 的消息的时候，前两步发现都没办法处理掉，走到第三步：

            ```
            - (void)forwardInvocation:(NSInvocation *)anInvocation {
                NSLog(@"forwardInvocation: %@", NSStringFromSelector([anInvocation selector]));
                if ([anInvocation selector] == @selector(code)) {
                    Monkey *monkey = [[Monkey alloc] init];
                    [anInvocation invokeWithTarget:monkey];
                }   
            }
            
            - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector {
                NSLog(@"method signature for selector: %@", NSStringFromSelector(aSelector));
                if (aSelector == @selector(code)) {
                    return [NSMethodSignature signatureWithObjCTypes:"V@:@"];
                }
                return [super methodSignatureForSelector:aSelector];
            }
            ```
            这时控制台会打印
            
            ```
            resolveInstanceMethod:  code
            forwardingTargetForSelector:  code
            method signature for selector: code
            forwardInvocation: code
            I am a coder.
            ```
            此时这个code消息已经被monkey实例处理掉
            此时消息转发流程完整的结束了，完整的消息转发流程如下：
            ![](media/15222324897236/15230977885514.png)


        4. 那么最后消息未能处理的时候，还会调用到
`- (void)doesNotRecognizeSelector:(SEL)aSelector`这个方法，我们也可以在这个方法中做些文章，避免掉crash，但是只建议在线上环境的时候做处理，实际开发过程中还要把异常抛出来


##多线程

* 线程同步：加锁
    1. @synchronized 关键字加锁
    2. NSLock 对象锁
    3. NSCondition
    4. NSConditionLock 条件锁
    5. NSRecursiveLock 递归锁
    6. pthread_mutex 互斥锁（C语言）
    7. dispatch_semaphore 信号量实现加锁（GCD）
    8. OSSpinLock

    OSSpinLock的性能最好，GCD的dispatch_semaphore其次，
 NSConditionLock和@synchronized性能较差；

    在iOS中有几种方法来解决多线程访问同一个内存地址的互斥同步问题：
    
    1. 方法一，@synchronized(id anObject),(最简单的方法)
会自动对参数对象加锁，保证临界区内的代码线程安全

        ```
        @synchronized(self)  
        {  
            // 这段代码对其他 @synchronized(self) 都是互斥的         
            // self 指向同一个对象   
        }    
        ```
    2. 方法二，NSLock

        NSLock对象实现了NSLocking protocol，包含几个方法：
        lock，加锁
        unlock，解锁
        tryLock，尝试加锁，如果失败了，并不会阻塞线程，只是立即返回NO
        lockBeforeDate:，在指定的date之前暂时阻塞线程（如果没有获取锁的话），如果到期还没有获取锁，则线程被唤醒，函数立即返回NO
        比如：

        ```
        NSLock *theLock = [[NSLock alloc] init];   
        if ([theLock lock])   
        {  
           //do something here  
            [theLock unlock];   
        }   
        ```
    3. 方法三，NSRecursiveLock，递归锁
        NSRecursiveLock，多次调用不会阻塞已获取该锁的线程。

        ```
        NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];   
        void MyRecursiveFunction(int value)   
        {   
          [theLock lock];   
         if (value != 0)   
         <span style="font-size:14px;"> </span>{   
             –value;   
             MyRecursiveFunction(value);   
         }  
          [theLock unlock];   
         }   
        MyRecursiveFunction(5);  
        ```
    4. 方法四，NSConditionLock，条件锁
        NSConditionLock，条件锁，可以设置条件

        ```
        //公共部分  
        id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];   
                
         //线程一，生产者  
          while(true) {   
                 [condLock lockWhenCondition:NO_DATA];   
                //生产数据  
                 [condLock unlockWithCondition:HAS_DATA];   
         }  
                
          //线程二，消费者  
          while (true) {   
                [condLock lockWhenCondition:HAS_DATA];   
                 //消费  
                 [condLock unlockWithCondition:NO_DATA];   
         }  
        ```
    5. 方法五，NSDistributedLock，分布锁
        NSDistributedLock，分布锁，文件方式实现，可以跨进程
        用tryLock方法获取锁。
        用unlock方法释放锁。
        如果一个获取锁的进程在释放锁之前挂了，那么锁就一直得不到释放了，此时可以通过breakLock强行获取锁。
    

* UI卡顿
    * 卡顿有可能是由于在主线程中进行了耗时操作或者网络请求操作。由于主线程是串行的，所以就会阻塞主线程，造成卡顿的现象。
    * 解决方案：耗时、网络操作放在子线程。
* 有些图片加载的比较慢怎么处理?你是怎么优化程序的性能的?
    1. 图片下载放在异步线程
    2. 图片下载过程中使用占位图片
    3. 如果图片较大，可以考虑多线程断点下载
    
###GCD
* 优点如下：
    * GCD 可用于多核的并行运算
    * GCD 会自动利用更多的 CPU 内核（比如双核、四核）
    * GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程）
    * 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码
* 任务：就是执行操作的意思，换句话说就是你在线程中执行的那段代码。在 GCD 中是放在 block 中的
    * 执行任务有两种方式：同步执行（sync）和异步执行（async）。两者的主要区别是：是否等待队列的任务执行结束，以及是否具备开启新线程的能力。
    * 同步执行（sync）：
        * 同步添加任务到指定的队列中，在添加的任务执行结束之前，会一直等待，直到队列里面的任务完成之后再继续执行。
        * 只能在当前线程中执行任务，不具备开启新线程的能力。
    * 异步执行（async）：
        * 异步添加任务到指定的队列中，它不会做任何等待，可以继续执行任务。
        * 可以在新的线程中执行任务，具备开启新线程的能力。
    * 注：异步执行（async）虽然具有开启新线程的能力，但是并不一定开启新线程。这跟任务所指定的队列类型有关
* 队列（Dispatch Queue）：这里的队列指执行任务的等待队列，即用来存放任务的队列。队列是一种特殊的线性表，采用 FIFO（先进先出）的原则，即新任务总是被插入到队列的末尾，而读取任务的时候总是从队列的头部开始读取。每读取一个任务，则从队列中释放一个任务。队列的结构可参考下图：
    ![](media/15222324897236/15224017082862.png)
    * 在 GCD 中有两种队列：串行队列和并发队列。两者都符合 FIFO（先进先出）的原则。两者的主要区别是：执行顺序不同，以及开启线程数不同。
    * 串行队列（Serial Dispatch Queue）：每次只有一个任务被执行。让任务一个接着一个地执行。（只开启一个线程，一个任务执行完毕后，再执行下一个任务）
    * 并发队列（Concurrent Dispatch Queue）：可以让多个任务并发（同时）执行。（可以开启多个线程，并且同时执行任务）
    * 注意：并发队列的并发功能只有在异步（dispatch_async）函数下才有效
* 使用步骤
    1. 创建一个队列（串行队列或并发队列）
    2. 将任务追加到任务的等待队列中，然后系统就会根据任务类型执行任务（同步执行或异步执行）
* 队列的创建方法/获取方法
    * 可以使用dispatch_queue_create来创建队列，需要传入两个参数，第一个参数表示队列的唯一标识符，用于 DEBUG，可为空，Dispatch Queue 的名称推荐使用应用程序 ID 这种逆序全程域名；第二个参数用来识别是串行队列还是并发队列。DISPATCH_QUEUE_SERIAL 表示串行队列，DISPATCH_QUEUE_CONCURRENT 表示并发队列。
        
        ```
        // 串行队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("com.baidu.serialQueue", DISPATCH_QUEUE_SERIAL);
// 并发队列的创建方法
dispatch_queue_t queue = dispatch_queue_create("com.baidu.concurrentQueue", DISPATCH_QUEUE_CONCURRENT);
        ```
    * 对于串行队列，GCD 提供了的一种特殊的串行队列：主队列（Main Dispatch Queue）。
        * 所有放在主队列中的任务，都会放到主线程中执行。
        * 可使用dispatch_get_main_queue()获得主队列。
    * 对于并发队列，GCD 默认提供了全局并发队列（Global Dispatch Queue）。
        * 可以使用dispatch_get_global_queue来获取。需要传入两个参数。第一个参数表示队列优先级，一般用DISPATCH_QUEUE_PRIORITY_DEFAULT。第二个参数暂时没用，用0即可。
            
            ```
            // 全局并发队列的获取方法
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
            ```

* 任务的创建方法 
    GCD 提供了同步执行任务的创建方法dispatch_sync和异步执行任务创建方法dispatch_async
    
    ```
    // 同步执行任务创建方法
dispatch_sync(queue, ^{
    // 这里放同步执行任务代码
});
// 异步执行任务创建方法
dispatch_async(queue, ^{
    // 这里放异步执行任务代码
});
    ```
    
    区别	|并行队列	|串行队列	|主队列
    --------- |--------- |--------- | ------------- 
同步(sync)	|没有开启新线程，串行执行任务	|没有开启新线程，串行执行任务	|主线程调用：死锁卡住不执行；
异步(async)	|有开启新线程，并发执行任务 |有开启新线程(1条)，串行执行任务	|没有开启新线程，串行执行任务
* 同步执行 + 并行队列：
    * 在当前线程中执行任务，不会开启新线程，执行完一个任务，再执行下一个任务。
* 异步执行 + 并行队列
    * 可以开启多个线程，任务交替（同时）执行。
*  同步执行 + 串行队列
    * 不会开启新线程，在当前线程执行任务。任务是串行的，执行完一个任务，再执行下一个任务。
* 异步执行 + 串行队列
    * 会开启新线程，但是因为任务是串行的，执行完一个任务，再执行下一个任务
* 同步执行 + 主队列
    * 同步执行 + 主队列在不同线程中调用结果也是不一样，在主线程中调用会出现死锁，而在其他线程中则不会。
    * 在主线程中调用同步执行 + 主队列
        1. 互相等待卡住
    * 在其它线程中调用同步执行 + 主队列 
        
        ```
        // 使用 NSThread 的 detachNewThreadSelector 方法会创建线程，并自动启动线程执行
 selector 任务
[NSThread detachNewThreadSelector:@selector(syncMain) toTarget:self withObject:nil];
        ```
        1. 不会开启新线程，执行完一个任务，再执行下一个任务
        2. 所有任务都是在主线程（非当前线程）中执行的，没有开启新的线程（所有放在主队列中的任务，都会放到主线程中执行）。
        3. 所有任务都在打印的syncConcurrent---begin和syncConcurrent---end之间执行（同步任务需要等待队列的任务执行结束）。
任务是按顺序执行的（主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。

* 异步执行 + 主队列
    * 只在主线程中执行任务，执行完一个任务，再执行下一个任务。
    * 所有任务都是在当前线程（主线程）中执行的，并没有开启新的线程（虽然异步执行具备开启线程的能力，但因为是主队列，所以所有任务都在主线程中）。
    * 所有任务是在打印的syncConcurrent—begin和syncConcurrent—end之后才开始执行的（异步执行不会做任何等待，可以继续执行任务）。
    * 任务是按顺序执行的（因为主队列是串行队列，每次只有一个任务被执行，任务一个接一个按顺序执行）。
    
* GCD 线程间的通信
    * 子线程执行耗时操作,主队线程刷新UI 
    * 每一个应用程序只有一个主线程即只有一个主队列，所以将任务添加到主队列,就是回到主线程了

* 其它方法
    1. GCD 栅栏方法：dispatch_barrier_async
        * 我们有时需要异步执行两组操作，而且第一组操作执行完之后，才能开始执行第二组操作。这样我们就需要一个相当于栅栏一样的一个方法将两组异步执行的操作组给分割起来，当然这里的操作组里可以包含一个或多个任务。这就需要用到dispatch_barrier_async方法在两个操作组间形成栅栏。
        * `dispatch_barrier_async`函数会等待前边追加到并发队列中的任务全部执行完毕之后，再将指定的任务追加到该异步队列中。然后在dispatch_barrier_async函数追加的任务执行完毕之后，异步队列才恢复为一般动作，接着追加任务到该异步队列并开始执行。具体如下图所示：  
             ![](media/15222324897236/15224233728059.png)
        
        
        ```
        /**
         * 栅栏方法 dispatch_barrier_async
         */
            - (void)barrier {
                dispatch_queue_t queue = dispatch_queue_create("net.bujige.testQueue", DISPATCH_QUEUE_CONCURRENT);
                
                dispatch_async(queue, ^{
                    // 追加任务1
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"1---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                });
                dispatch_async(queue, ^{
                    // 追加任务2
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"2---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                });
                
                dispatch_barrier_async(queue, ^{
                    // 追加任务 barrier
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"barrier---%@",[NSThread currentThread]);// 打印当前线程
                    }
                });
                
                dispatch_async(queue, ^{
                    // 追加任务3
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"3---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                });
                dispatch_async(queue, ^{
                    // 追加任务4
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"4---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                });
            }
            
        输出结果：
            1—{number = 4, name = (null)}
            2—{number = 3, name = (null)}
            1—{number = 4, name = (null)}
            2—{number = 3, name = (null)}
            barrier—{number = 4, name = (null)}
            barrier—{number = 4, name = (null)}
            4—{number = 3, name = (null)}
            3—{number = 4, name = (null)}
            4—{number = 3, name = (null)}
            3—{number = 4, name = (null)}
            
        在dispatch_barrier_async执行结果中可以看出：

            在执行完栅栏前面的操作之后，才执行栅栏操作，最后再执行栅栏后边的操作。
        
        ```

* GCD 延时执行方法：dispatch_after
    * 我们经常会遇到这样的需求：在指定时间（例如3秒）之后执行某个任务。可以用 GCD 的dispatch_after函数来实现。
    * 需要注意的是：dispatch_after函数并不是在指定时间之后才开始执行处理，而是在指定时间之后将任务追加到主队列中。严格来说，这个时间并不是绝对准确的，但想要大致延迟执行任务，dispatch_after函数是很有效的。

        ```
        /**
         * 延时执行方法 dispatch_after
         */
    - (void)after {
        NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
        NSLog(@"asyncMain---begin");
        
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            // 2.0秒后异步追加任务代码到主队列，并开始执行
            NSLog(@"after---%@",[NSThread currentThread]);  // 打印当前线程
        });
    }
    ```

* GCD 一次性代码（只执行一次）：dispatch_once
    * 我们在创建单例、或者有整个程序运行过程中只执行一次的代码时，我们就用到了 GCD 的 dispatch_once 函数。使用
    * dispatch_once 函数能保证某段代码在程序运行过程中只被执行1次，并且即使在多线程的环境下，dispatch_once也可以保证线程安全。 
    
* GCD 快速迭代方法：dispatch_apply
    * 通常我们会用 for 循环遍历，但是 GCD 给我们提供了快速迭代的函数 dispatch_apply。dispatch_apply 按照指定的次数将指定的任务追加到指定的队列中，并等待全部队列执行结束。
    * 如果是在串行队列中使用 dispatch_apply，那么就和 for 循环一样，按顺序同步执行。可这样就体现不出快速迭代的意义了。
        
     我们可以利用并发队列进行异步执行。比如说遍历 0~5 这6个数字，for 循环的做法是每次取出一个元素，逐个遍历。dispatch_apply 可以 在多个线程中同时（异步）遍历多个数字。
还有一点，无论是在串行队列，还是异步队列中，dispatch_apply 都会等待全部任务执行完毕，这点就像是同步操作，也像是队列组中的 dispatch_group_wait方法。
    
     ```
     /**
      * 快速迭代方法 dispatch_apply
      */
    - (void)apply {
        dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
        
        NSLog(@"apply---begin");
        dispatch_apply(6, queue, ^(size_t index) {
            NSLog(@"%zd---%@",index, [NSThread currentThread]);
        });
        NSLog(@"apply---end");
    }
    
        输出结果：
        apply—begin
        1—{number = 3, name = (null)}
        0—{number = 1, name = main}
        2—{number = 4, name = (null)}
        3—{number = 5, name = (null)}
        4—{number = 3, name = (null)}
        5—{number = 1, name = main}
        apply—end
        
        因为是在并发队列中异步队执行任务，所以各个任务的执行时间长短不定，最后结束顺序也不定。但是apply---end一定在最后执行。这是因为dispatch_apply函数会等待全部任务执行完毕。
     ```
    
* GCD 的队列组：dispatch_group
    * 有时候我们会有这样的需求：分别异步执行2个耗时任务，然后当2个耗时任务都执行完毕后再回到主线程执行任务。这时候我们可以用到 GCD 的队列组。
    * 调用队列组的 `dispatch_group_async` 先把任务放到队列中，然后将队列放入队列组中。或者使用队列组的 `dispatch_group_enter`、`dispatch_group_leave` 组合 来实现 `dispatch_group_async`。
    * 调用队列组的 dispatch_group_notify 回到指定线程执行任务。或者使用 dispatch_group_wait 回到当前线程继续向下执行（会阻塞当前线程）。
    1. dispatch_group_notify
        1. 监听 group 中任务的完成状态，当所有的任务都执行完成后，追加任务到 group 中，并执行任务。
        
            ```
        /**
         * 队列组 dispatch_group_notify
         */
        - (void)groupNotify {
            NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
            NSLog(@"group---begin");
            
            dispatch_group_t group =  dispatch_group_create();
            
            dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                // 追加任务1
                for (int i = 0; i < 2; ++i) {
                    [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                    NSLog(@"1---%@",[NSThread currentThread]);      // 打印当前线程
                }
            });
            
            dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                // 追加任务2
                for (int i = 0; i < 2; ++i) {
                    [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                    NSLog(@"2---%@",[NSThread currentThread]);      // 打印当前线程
                }
            });
            
            dispatch_group_notify(group, dispatch_get_main_queue(), ^{
                // 等前面的异步任务1、任务2都执行完毕后，回到主线程执行下边任务
                for (int i = 0; i < 2; ++i) {
                    [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                    NSLog(@"3---%@",[NSThread currentThread]);      // 打印当前线程
                }
                NSLog(@"group---end");
            });
        }
        
            输出结果：
            currentThread—{number = 1, name = main}
            group—begin
            1—{number = 4, name = (null)}
            2—{number = 3, name = (null)}
            2—{number = 3, name = (null)}
            1—{number = 4, name = (null)}
            3—{number = 1, name = main}
            3—{number = 1, name = main}
            group—end
            
            从dispatch_group_notify相关代码运行输出结果可以看出：
    当所有任务都执行完成之后，才执行dispatch_group_notify block 中的任务。
        ```
     2. dispatch_group_wait
        
            * 暂停当前线程（阻塞当前线程），等待指定的 group 中的任务执行完成后，才会往下继续执行。
            
            ```
            /**
             * 队列组 dispatch_group_wait
             */
        - (void)groupWait {
            NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
            NSLog(@"group---begin");
            
            dispatch_group_t group =  dispatch_group_create();
            
            dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                // 追加任务1
                for (int i = 0; i < 2; ++i) {
                    [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                    NSLog(@"1---%@",[NSThread currentThread]);      // 打印当前线程
                }
            });
            
            dispatch_group_async(group, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                // 追加任务2
                for (int i = 0; i < 2; ++i) {
                    [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                    NSLog(@"2---%@",[NSThread currentThread]);      // 打印当前线程
                }
            });
            
            // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
            dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
            
            NSLog(@"group---end");
        }
            输出结果：
            currentThread—{number = 1, name = main}
            group—begin
            2—{number = 4, name = (null)}
            1—{number = 3, name = (null)}
            2—{number = 4, name = (null)}
            1—{number = 3, name = (null)}
            group—end
            
            从dispatch_group_wait相关代码运行输出结果可以看出：
当所有任务执行完成之后，才执行 dispatch_group_wait 之后的操作。但是，使用dispatch_group_wait 会阻塞当前线程。
            ```
    
        3. dispatch_group_enter、dispatch_group_leave
            * dispatch_group_enter 标志着一个任务追加到 group，执行一次，相当于 group 中未执行完毕任务数+1
            * dispatch_group_leave 标志着一个任务离开了 group，执行一次，相当于 group 中未执行完毕任务数-1。
            * 当 group 中未执行完毕任务数为0的时候，才会使dispatch_group_wait解除阻塞，以及执行追加到dispatch_group_notify中的任务。
         
            ```
            /**
             * 队列组 dispatch_group_enter、dispatch_group_leave
             */
            - (void)groupEnterAndLeave
            {
                NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
                NSLog(@"group---begin");
                
                dispatch_group_t group = dispatch_group_create();
                dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
                dispatch_group_enter(group);
                dispatch_async(queue, ^{
                    // 追加任务1
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"1---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                    dispatch_group_leave(group);
                });
                
                dispatch_group_enter(group);
                dispatch_async(queue, ^{
                    // 追加任务2
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"2---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                    dispatch_group_leave(group);
                });
                
                dispatch_group_notify(group, dispatch_get_main_queue(), ^{
                    // 等前面的异步操作都执行完毕后，回到主线程.
                    for (int i = 0; i < 2; ++i) {
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"3---%@",[NSThread currentThread]);      // 打印当前线程
                    }
                    NSLog(@"group---end");
                });
                
            //    // 等待上面的任务全部完成后，会往下继续执行（会阻塞当前线程）
            //    dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
            //
            //    NSLog(@"group---end");
            }
            
            输出结果:
            currentThread—{number = 1, name = main}
            group—begin
            1—{number = 4, name = (null)}
            2—{number = 3, name = (null)}
            1—{number = 4, name = (null)}
            2—{number = 3, name = (null)}
            3—{number = 1, name = main}
            3—{number = 1, name = main}
            group—end
            
            从dispatch_group_enter、dispatch_group_leave相关代码运行结果中可以看出：当所有任务执行完成之后，才执行 dispatch_group_notify 中的任务。这里的dispatch_group_enter、dispatch_group_leave组合，其实等同于dispatch_group_async。
            ```
        
        4. GCD 信号量：dispatch_semaphore
            * GCD 中的信号量是指 Dispatch Semaphore，是持有计数的信号。类似于过高速路收费站的栏杆。可以通过时，打开栏杆，不可以通过时，关闭栏杆。在 Dispatch Semaphore 中，使用计数来完成这个功能，计数为0时等待，不可通过。计数为1或大于1时，计数减1且不等待，可通过。Dispatch Semaphore 提供了三个函数。
                * dispatch_semaphore_create：创建一个Semaphore并初始化信号的总量
                * dispatch_semaphore_signal：发送一个信号，让信号总量加1
                * dispatch_semaphore_wait：可以使总信号量减1，当信号总量为0时就会一直等待（阻塞所在线程），否则就可以正常执行。
                * 注意：信号量的使用前提是：想清楚你需要处理哪个线程等待（阻塞），又要哪个线程继续执行，然后使用信号量。
            * Dispatch Semaphore 在实际开发中主要用于：
                1. 保持线程同步，将异步执行任务转换为同步执行任务
                2. 保证线程安全，为线程加锁
            *  Dispatch Semaphore 线程同步
                * 我们在开发中，会遇到这样的需求：异步执行耗时任务，并使用异步执行的结果进行一些额外的操作。换句话说，相当于，将将异步执行任务转换为同步执行任务。比如说：AFNetworking 中 AFURLSessionManager.m 里面的 `tasksForKeyPath:` 方法。通过引入信号量的方式，等待异步执行任务结果，获取到 tasks，然后再返回该 tasks。
                    
                    ```
                    - (NSArray *)tasksForKeyPath:(NSString *)keyPath {
                    __block NSArray *tasks = nil;
                    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
                    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) {
                        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) {
                            tasks = dataTasks;
                        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) {
                            tasks = uploadTasks;
                        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) {
                            tasks = downloadTasks;
                        } else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) {
                            tasks = [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@"@unionOfArrays.self"];
                        }
                
                        dispatch_semaphore_signal(semaphore);
                    }];
                
                    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
                
                    return tasks;
                    }
                    ```
                    ```
                    利用 Dispatch Semaphore 实现线程同步，将异步执行任务转换为同步执行任务。
                    /**
                     * semaphore 线程同步
                     */
                - (void)semaphoreSync {
                    
                    NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
                    NSLog(@"semaphore---begin");
                    
                    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
                    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
                    
                    __block int number = 0;
                    dispatch_async(queue, ^{
                        // 追加任务1
                        [NSThread sleepForTimeInterval:2];              // 模拟耗时操作
                        NSLog(@"1---%@",[NSThread currentThread]);      // 打印当前线程
                        
                        number = 100;
                        
                        dispatch_semaphore_signal(semaphore);
                    });
                    
                    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
                    NSLog(@"semaphore---end,number = %zd",number);
                }
                
                    输出结果:
                    currentThread—{number = 1, name = main}
                    semaphore—begin
                    1—{number = 3, name = (null)}
                    semaphore—end,number = 100
                    ```
                *  从 Dispatch Semaphore 实现线程同步的代码可以看到：
                    * semaphore---end 是在执行完 number = 100; 之后才打印的。而且输出结果 number 为 100。这是因为异步执行不会做任何等待，可以继续执行任务。异步执行将任务1追加到队列之后，不做等待，接着执行dispatch_semaphore_wait方法。此时 semaphore == 0，当前线程进入等待状态。然后，异步任务1开始执行。任务1执行到dispatch_semaphore_signal之后，总信号量，此时 semaphore == 1，dispatch_semaphore_wait方法使总信号量减1，正在被阻塞的线程（主线程）恢复继续执行。最后打印semaphore---end,number = 100。这样就实现了线程同步，将异步执行任务转换为同步执行任务。
            * Dispatch Semaphore 线程安全和线程同步（为线程加锁）
                * 线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
                * 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。
                * 线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。
                * 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。
                * 例子:
                
                    ```
                    /**
                     * 非线程安全：不使用 semaphore
                     * 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票
                     */
                    - (void)initTicketStatusNotSave {
                        NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
                        NSLog(@"semaphore---begin");
                        
                        self.ticketSurplusCount = 50;
                        
                        // queue1 代表北京火车票售卖窗口
                        dispatch_queue_t queue1 = dispatch_queue_create("net.bujige.testQueue1", DISPATCH_QUEUE_SERIAL);
                        // queue2 代表上海火车票售卖窗口
                        dispatch_queue_t queue2 = dispatch_queue_create("net.bujige.testQueue2", DISPATCH_QUEUE_SERIAL);
                        
                        __weak typeof(self) weakSelf = self;
                        dispatch_async(queue1, ^{
                            [weakSelf saleTicketNotSafe];
                        });
                        
                        dispatch_async(queue2, ^{
                            [weakSelf saleTicketNotSafe];
                        });
                    }
                    
                    /**
                     * 售卖火车票(非线程安全)
                     */
                    - (void)saleTicketNotSafe {
                        while (1) {
                            
                            if (self.ticketSurplusCount > 0) {  //如果还有票，继续售卖
                                self.ticketSurplusCount--;
                                NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]);
                                [NSThread sleepForTimeInterval:0.2];
                            } else { //如果已卖完，关闭售票窗口
                                NSLog(@"所有火车票均已售完");
                                break;
                            }
                            
                        }
                    }
                    
                    输出结果：
                    currentThread—{number = 1, name = main}
                    剩余票数：48 窗口：{number = 3, name = (null)}
                    剩余票数：49 窗口：{number = 4, name = (null)}
                    剩余票数：47 窗口：{number = 4, name = (null)}
                    ......
                    
                    可以看到在不考虑线程安全，不使用 semaphore 的情况下，得到票数是错乱的，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。
                    
                    
                    /**
                     * 线程安全：使用 semaphore 加锁
                     * 初始化火车票数量、卖票窗口(线程安全)、并开始卖票
                     */
                    - (void)initTicketStatusSave {
                        NSLog(@"currentThread---%@",[NSThread currentThread]);  // 打印当前线程
                        NSLog(@"semaphore---begin");
                        
                        semaphoreLock = dispatch_semaphore_create(1);
                        
                        self.ticketSurplusCount = 50;
                        
                        // queue1 代表北京火车票售卖窗口
                        dispatch_queue_t queue1 = dispatch_queue_create("net.bujige.testQueue1", DISPATCH_QUEUE_SERIAL);
                        // queue2 代表上海火车票售卖窗口
                        dispatch_queue_t queue2 = dispatch_queue_create("net.bujige.testQueue2", DISPATCH_QUEUE_SERIAL);
                        
                        __weak typeof(self) weakSelf = self;
                        dispatch_async(queue1, ^{
                            [weakSelf saleTicketSafe];
                        });
                        
                        dispatch_async(queue2, ^{
                            [weakSelf saleTicketSafe];
                        });
                    }
                    
                    /**
                     * 售卖火车票(线程安全)
                     */
                    - (void)saleTicketSafe {
                        while (1) {
                            // 相当于加锁
                            dispatch_semaphore_wait(semaphoreLock, DISPATCH_TIME_FOREVER);
                            
                            if (self.ticketSurplusCount > 0) {  //如果还有票，继续售卖
                                self.ticketSurplusCount--;
                                NSLog(@"%@", [NSString stringWithFormat:@"剩余票数：%d 窗口：%@", self.ticketSurplusCount, [NSThread currentThread]]);
                                [NSThread sleepForTimeInterval:0.2];
                            } else { //如果已卖完，关闭售票窗口
                                NSLog(@"所有火车票均已售完");
                                
                                // 相当于解锁
                                dispatch_semaphore_signal(semaphoreLock);
                                break;
                            }
                            
                            // 相当于解锁
                            dispatch_semaphore_signal(semaphoreLock);
                        }
                    }
                    
                    输出结果：
                    currentThread—{number = 1, name = main}
                    semaphore—begin
                    剩余票数：49 窗口：{number = 3, name = (null)}
                    剩余票数：48 窗口：{number = 4, name = (null)}
                    剩余票数：47 窗口：{number = 3, name = (null)}
                    ......
                    剩余票数：3 窗口：{number = 3, name = (null)}
                    剩余票数：2 窗口：{number = 4, name = (null)}
                    剩余票数：1 窗口：{number = 3, name = (null)}
                    剩余票数：0 窗口：{number = 4, name = (null)}
                    所有火车票均已售完
                    所有火车票均已售完
                    
                    可以看出，在考虑了线程安全的情况下，使用 dispatch_semaphore
机制之后，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。
                    ```

### pthread
* pthread 是一套通用的多线程的 API，可以在Unix / Linux / Windows 等系统跨平台使用，使用 C 语言编写，需要程序员自己管理线程的生命周期，使用难度较大，我们在 iOS 开发中几乎不使用 pthread，但是还是来可以了解一下的。
* POSIX 线程（英语：POSIX Threads，常被缩写 为 Pthreads）是 POSIX 的线程标准，定义了创建和操纵线程的一套 API。

    实现 POSIX 线程标准的库常被称作 Pthreads，一般用于 Unix-like POSIX 系统，如 Linux、Solaris。但是 Microsoft Windows 上的实现也存在，例如直接使用 Windows API 实现的第三方库 pthreads-w32；而利用 Windows 的 SFU/SUA 子系统，则可以使用微软提供的一部分原生 POSIX API。

##网络
* TCP和UDP

* App需要加载超大量的数据，给服务器发送请求，但是服务器卡住了如何解决？
    1. 设置请求超时
    2. 给用户提示请求超时
    3. 根据用户操作再次请求数据

* 如果在网络数据处理过程中,发现一处比较卡,一般怎么解决?
    1. 检查网络请求操作是否被放在主线程了
    2. 看看异步请求的数量是否太多了（子线程数量）
    3. 数据量是否太大？如果太大，先清除一些不必要的对象（看不见的数据、图片）
    4. 手机CPU使用率和内存问题
    
* sip是什么？
    1. SIP（Session Initiation Protocol），会话发起协议
    2.  SIP是建立VOIP连接的 IETF 标准，IETF是全球互联网最具权威的技术标准化组织
    3. 所谓VOIP，就是网络电话，直接用互联网打电话，不用耗手机话费


## 文章推荐
* [RunLoop](https://blog.ibireme.com/2015/05/18/runloop), Y 神的这篇 RunLoop 无人能及，这篇文章出世之后，讲不了 RunLoop 都不好意思说自己是 iOS 工程师。
* [多线程](http://xuyafei.cn/post/draft/ios-thread)，这是我前同事 亚非 整理的多线程知识，很赞，可以对照着系统梳理一下。
* [事件传递](https://www.jianshu.com/p/2e074db792ba), 讲事件传递的博客很多，这篇讲得挺详细的。
* [组件化](https://blog.cnbang.net/tech/3080)，现在大公司都刚刚做完组件化，面试也是必问的题，业界基本就两个方案，把 bang、Casa 和 蘑菇街 的文章都仔细读一下，面试能讲清楚各自的实现方案以及主要问题就行。
* [Alamofire源码解读](https://juejin.im/entry/5947ae51a0bb9f006bdd3241)，配合这篇文章，看源码要轻松一些。
* [sunny的面试题](http://blog.sunnyxx.com/2015/07/04/ios-interview/)，这套题虽然是15年的，现在面试问的还是这些，没多少变化，另外 github 上有人给这套题出了答案。
* [Peak的面试题](http://mrpeak.cn/ios/2016/01/07/push)，面试题大多类似，不用刷太多篇。

